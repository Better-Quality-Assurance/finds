/**
 * Examples of using the retry utility in various scenarios
 *
 * This file demonstrates common use cases for withRetry and withRetrySafe
 * across different parts of the application.
 */

import { withRetry, withRetrySafe } from './retry'

// Placeholder declarations for example code - these would be imported in real usage
declare const prisma: any
declare const someStorageService: any

// ============================================================================
// EXAMPLE 1: External API Call with Retry
// ============================================================================

export async function fetchExternalCarData(vin: string): Promise<any> {
  return withRetry(
    async () => {
      const response = await fetch(`https://api.example.com/vehicles/${vin}`)

      if (!response.ok) {
        if (response.status >= 500) {
          // Server error - retryable
          throw new Error(`Server error: ${response.status}`)
        }
        if (response.status === 429) {
          // Rate limited - retryable
          throw new Error('Rate limited')
        }
        // Client errors (4xx) - not retryable
        throw new Error(`Client error: ${response.status}`)
      }

      return response.json()
    },
    {
      maxRetries: 3,
      baseDelay: 1000,
      shouldRetry: (error) => {
        // Only retry on server errors and rate limits
        return error.message.includes('Server error') ||
               error.message.includes('Rate limited')
      },
      onRetry: (attempt, error) => {
        console.log(`Retrying car data fetch (attempt ${attempt}):`, error.message)
      },
    }
  )
}

// ============================================================================
// EXAMPLE 2: Image Upload with Safe Result
// ============================================================================

export async function uploadImageToStorage(
  buffer: Buffer,
  key: string
): Promise<{ url: string | null; error?: string }> {
  const result = await withRetrySafe(
    async () => {
      // Simulate storage upload
      const url = await someStorageService.upload(buffer, key)
      return url
    },
    {
      maxRetries: 3,
      baseDelay: 500, // Faster retries for storage
      onRetry: (attempt, error) => {
        console.warn(`Upload retry ${attempt}/3 for ${key}:`, error.message)
      },
    }
  )

  if (result.success) {
    return { url: result.value! }
  } else {
    return {
      url: null,
      error: result.error?.message || 'Upload failed',
    }
  }
}

// ============================================================================
// EXAMPLE 3: Database Transaction with Custom Retry Logic
// ============================================================================

export async function createAuctionWithRetry(data: any) {
  return withRetry(
    async () => {
      // Database operations that might fail due to deadlock
      return await prisma.$transaction(async (tx) => {
        const auction = await tx.auction.create({ data })
        // ... more operations
        return auction
      })
    },
    {
      maxRetries: 5, // More retries for deadlock scenarios
      baseDelay: 200, // Shorter delays for DB
      shouldRetry: (error) => {
        // Only retry on specific Prisma errors
        return error.message.includes('deadlock') ||
               error.message.includes('timeout')
      },
    }
  )
}

// ============================================================================
// EXAMPLE 4: Email Sending with Exponential Backoff
// ============================================================================

export async function sendEmailWithRetry(
  to: string,
  subject: string,
  body: string
): Promise<void> {
  const result = await withRetrySafe(
    async () => {
      // Use Resend or other email service
      await emailService.send({ to, subject, body })
    },
    {
      maxRetries: 3,
      baseDelay: 2000, // 2s, 4s, 8s for email
      onRetry: (attempt, error) => {
        console.error(
          `Email send failed (attempt ${attempt}/3) to ${to}:`,
          error.message
        )
      },
    }
  )

  if (!result.success) {
    // Log to monitoring service
    console.error(
      `CRITICAL: Email delivery failed after ${result.attempts} attempts to ${to}`,
      result.error
    )

    // Could trigger alert or add to dead-letter queue
    throw new Error(`Email delivery failed: ${result.error?.message}`)
  }
}

// ============================================================================
// EXAMPLE 5: Webhook Delivery
// ============================================================================

export async function deliverWebhook(
  url: string,
  payload: any
): Promise<boolean> {
  const result = await withRetrySafe(
    async () => {
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      })

      if (!response.ok) {
        throw new Error(`Webhook failed: ${response.status}`)
      }

      return true
    },
    {
      maxRetries: 5, // More retries for webhooks
      baseDelay: 1000, // 1s, 2s, 4s, 8s, 16s
      shouldRetry: (error) => {
        // Don't retry on client errors
        return !error.message.includes('4')
      },
      onRetry: (attempt, error) => {
        console.log(`Webhook retry ${attempt} to ${url}:`, error.message)
      },
    }
  )

  return result.success
}

// ============================================================================
// EXAMPLE 6: AI/ML Model Inference
// ============================================================================

export async function analyzeImageWithAI(imageUrl: string): Promise<any> {
  return withRetry(
    async () => {
      const response = await fetch('https://ai-service.example.com/analyze', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ imageUrl }),
      })

      if (!response.ok) {
        throw new Error(`AI service error: ${response.status}`)
      }

      return response.json()
    },
    {
      maxRetries: 3,
      baseDelay: 3000, // AI services might be slower
      shouldRetry: (error) => {
        // Retry on service errors, not client errors
        const status = error.message.match(/\d{3}/)?.[0]
        return !status || parseInt(status) >= 500
      },
      onRetry: (attempt, error) => {
        console.log(`AI analysis retry ${attempt} for ${imageUrl}:`, error.message)
      },
    }
  )
}

// ============================================================================
// EXAMPLE 7: Batch Processing with Partial Failures
// ============================================================================

export async function processBatchWithRetry<T>(
  items: T[],
  processor: (item: T) => Promise<void>
): Promise<{ succeeded: T[]; failed: Array<{ item: T; error: Error }> }> {
  const succeeded: T[] = []
  const failed: Array<{ item: T; error: Error }> = []

  for (const item of items) {
    const result = await withRetrySafe(
      async () => await processor(item),
      {
        maxRetries: 3,
        baseDelay: 500,
        onRetry: (attempt, error) => {
          console.log(`Batch item retry ${attempt}:`, error.message)
        },
      }
    )

    if (result.success) {
      succeeded.push(item)
    } else {
      failed.push({ item, error: result.error! })
    }
  }

  return { succeeded, failed }
}

// ============================================================================
// EXAMPLE 8: Stripe Payment with Idempotency
// ============================================================================

export async function createStripePaymentIntent(
  amount: number,
  currency: string,
  customerId: string
): Promise<string> {
  // Generate idempotency key once
  const idempotencyKey = `payment_${customerId}_${Date.now()}`

  return withRetry(
    async () => {
      const paymentIntent = await stripe.paymentIntents.create(
        {
          amount,
          currency,
          customer: customerId,
        },
        {
          idempotencyKey, // Same key for all retries
        }
      )

      return paymentIntent.id
    },
    {
      maxRetries: 3,
      baseDelay: 1000,
      shouldRetry: (error: any) => {
        // Retry on network errors, not on invalid parameters
        return error.type !== 'StripeInvalidRequestError'
      },
      onRetry: (attempt, error) => {
        console.warn(`Stripe payment retry ${attempt}:`, error.message)
      },
    }
  )
}

// ============================================================================
// EXAMPLE 9: File Download with Progress Tracking
// ============================================================================

export async function downloadFileWithRetry(
  url: string,
  onProgress?: (percent: number) => void
): Promise<Buffer> {
  return withRetry(
    async () => {
      const response = await fetch(url)

      if (!response.ok) {
        throw new Error(`Download failed: ${response.status}`)
      }

      const contentLength = parseInt(
        response.headers.get('content-length') || '0',
        10
      )
      const chunks: Buffer[] = []
      let downloadedBytes = 0

      const reader = response.body?.getReader()
      if (!reader) {
        throw new Error('No response body')
      }

      while (true) {
        const { done, value } = await reader.read()

        if (done) break

        chunks.push(Buffer.from(value))
        downloadedBytes += value.length

        if (onProgress && contentLength > 0) {
          onProgress((downloadedBytes / contentLength) * 100)
        }
      }

      return Buffer.concat(chunks)
    },
    {
      maxRetries: 3,
      baseDelay: 2000,
      onRetry: (attempt, error) => {
        console.log(`Download retry ${attempt} for ${url}:`, error.message)
      },
    }
  )
}

// ============================================================================
// EXAMPLE 10: Cache Warming with Safe Result
// ============================================================================

export async function warmCacheWithRetry(
  key: string,
  fetcher: () => Promise<any>
): Promise<void> {
  const result = await withRetrySafe(
    async () => {
      const data = await fetcher()
      await cache.set(key, data, { ttl: 3600 })
      return data
    },
    {
      maxRetries: 2, // Fewer retries for cache warming
      baseDelay: 1000,
      onRetry: (attempt, error) => {
        console.log(`Cache warm retry ${attempt} for ${key}:`, error.message)
      },
    }
  )

  if (!result.success) {
    // Cache warming failure is not critical - just log
    console.warn(`Cache warm failed for ${key} after ${result.attempts} attempts`)
  }
}

// ============================================================================
// Placeholder services for examples
// ============================================================================

const prisma = {
  $transaction: async <T>(fn: (tx: any) => Promise<T>): Promise<T> => {
    // Placeholder
    return fn({
      auction: {
        create: async (params: any) => ({ id: 'auction_123', ...params.data }),
      },
    })
  },
}

const someStorageService = {
  upload: async (buffer: Buffer, key: string): Promise<string> => {
    // Placeholder
    return `https://example.com/${key}`
  },
}

const emailService = {
  send: async (params: { to: string; subject: string; body: string }) => {
    // Placeholder
  },
}

const stripe = {
  paymentIntents: {
    create: async (params: any, options: any): Promise<{ id: string }> => {
      // Placeholder
      return { id: 'pi_123' }
    },
  },
}

const cache = {
  set: async (key: string, value: any, options: any) => {
    // Placeholder
  },
}
